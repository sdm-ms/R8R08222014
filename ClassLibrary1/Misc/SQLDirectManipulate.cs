using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Data.Linq;
using System.Data;
using System.Data.SqlClient;
using System.ComponentModel;

namespace ClassLibrary1.Misc
{
    public class SQLConstants
    {
        public const int SQLMaxParameters = 2100; // this is a SQL Server maximum that we will need to abide by -- we assume that we will have no more than 2100 per row
    }

    public enum SQLColumnType
    {
        typeInt,
        typeStringUnlimited,
        typeString4Chars,
        typeString150Chars,
        typeDecimal,
        typeGeography,
        typeDateTime,
        typeBit
    }

    public class SQLTableColumnDescription
    {
        public string Name { get; set; }
        public SQLColumnType ColType { get; set; }
        public bool Nullable { get; set; }
        public bool PrimaryKey { get; set; }
        public bool AutoIncrement { get; set; }
        public bool NonclusteredIndex { get; set; }
        [DefaultValue(false)]
        public bool ClusteredIndex { get; set; }
        public bool Ascending { get; set; }
        public string ComputedColumnSpecification { get; set; }
        public string DefaultValue = "";

        public string ColTypeString()
        {
            switch (ColType)
            {
                case SQLColumnType.typeBit:
                    return "[bit]";
                case SQLColumnType.typeDateTime:
                    return "[datetime]";
                case SQLColumnType.typeDecimal:
                    return "[decimal](18,4)";
                case SQLColumnType.typeGeography:
                    return "[geography]";
                case SQLColumnType.typeInt:
                    return "[int]";
                case SQLColumnType.typeStringUnlimited:
                    if (NonclusteredIndex || ClusteredIndex)
                        throw new Exception("Can't create an index on a string of unlimited size."); // MAX can't be used on indexed columns -- can create a smaller column and index on that. Then sort on that followed by this
                    return "[nvarchar](MAX)";
                case SQLColumnType.typeString4Chars:
                    return "[nchar](4)";
                case SQLColumnType.typeString150Chars:
                    return "[nvarchar](150)";
                default:
                    throw new Exception("Unknown ColType");
            }
        }

        public Type GetColumnType()
        {
            switch (ColType)
            {
                case SQLColumnType.typeBit:
                    return System.Type.GetType("System.Boolean");
                case SQLColumnType.typeDateTime:
                    return System.Type.GetType("System.DateTime");
                case SQLColumnType.typeDecimal:
                    return System.Type.GetType("System.Decimal");
                case SQLColumnType.typeGeography:
                    return typeof(Microsoft.SqlServer.Types.SqlGeography);
                case SQLColumnType.typeInt:
                    return System.Type.GetType("System.Int32");
                case SQLColumnType.typeStringUnlimited:
                    return System.Type.GetType("System.String");
                default:
                    throw new Exception("Unknown ColType");
            }
        }

        internal string ToSpecificationString()
        {
            if (ComputedColumnSpecification != null && ComputedColumnSpecification != "")
                return Name + ComputedColumnSpecification;
            return String.Format("[{0}] {1} {2} {3} {4} {5}{6}", Name, ColTypeString(), Nullable ? "NULL" : "NOT NULL", DefaultValue != "" ? "DEFAULT " + DefaultValue : "",  AutoIncrement ? "IDENTITY" : "", PrimaryKey && !ClusteredIndex ? "PRIMARY KEY NONCLUSTERED" : "", PrimaryKey && ClusteredIndex ? "PRIMARY KEY" : "");
        }

        public DataColumn GetDataColumn()
        {
            DataColumn column = new DataColumn();
            column.DataType = GetColumnType();
            column.ColumnName = Name;
            return column;
        }
    }

    public class SQLTableDescription
    {
        public string Name { get; set; }
        public List<SQLTableColumnDescription> Columns { get; set; }

        public List<DataColumn> GetDataColumns(bool includeIDColumn = true)
        {
            return Columns.Where(x => includeIDColumn || !x.PrimaryKey).Select(x => x.GetDataColumn()).ToList();
        }
    }

    public interface ISQLDirectConnectionManager
    {
        string GetConnectionString();
    }

    [Serializable]
    public class SQLUpdateInfoTableSpecification
    {
        public bool IDIsAutogenerated; // so it doesn't need to be set unless we're updating
        public bool HasSameIDAsMainTable = true; // relevant only if there is an ID 
        public string Tablename;
        public string PrimaryKeyFieldName; // if applicable
        public SQLUpdateInfoTableSpecification MainTable; // if this is a secondary table, set this to main table
        public bool IsMainTable { get { return MainTable == null; } }
        public bool IsSecondaryTable { get { return MainTable != null; } }
    }

    [Serializable]
    public class SQLInfoForCellsInRow_MainAndSecondaryTables
    {
        public List<SQLCellInfo> SQLUpdateInfos = new List<SQLCellInfo>(); // contains ALL SQLUpdateInfos, regardless of table
        public bool IsAlreadyProcessed { get { return SQLUpdateInfos.All(x => x.AlreadyProcessed); } }
        public List<SQLInfoForCellsInRow_SingleTable> Subgroups = new List<SQLInfoForCellsInRow_SingleTable>();
        public int? MainTablePrimaryKey = null;

        public SQLUpdateInfoTableSpecification DefaultTableSpec = null;

        public List<SQLCellInfo> itemsToUpdateWithMainTablePrimaryKeyOnceAvailable = new List<SQLCellInfo>();

        public void SetMainTablePrimaryKey(int primaryKey, bool isAlreadyInDatabase)
        {
            if (MainTablePrimaryKey != null && MainTablePrimaryKey != primaryKey)
                throw new Exception("Cannot change primary key.");
            if (MainTablePrimaryKey != null)
                return;
            foreach (var subgroup in Subgroups)
            {
                if (subgroup.TableSpec.HasSameIDAsMainTable)
                    Add(new SQLCellInfo() { Rownum = primaryKey, Value = primaryKey, Fieldname = subgroup.TableSpec.PrimaryKeyFieldName, DBtype = SqlDbType.Int, DataIsAlreadyInDatabase = isAlreadyInDatabase }, subgroup.TableSpec);
            }
        }

        public void AddToListOfTablenames(List<string> tablenameList)
        {
            foreach (SQLInfoForCellsInRow_SingleTable subgroup in Subgroups)
                if (!tablenameList.Contains(subgroup.TableSpec.Tablename))
                    tablenameList.Add(subgroup.TableSpec.Tablename);
        }

        public SQLInfoForCellsInRow_SingleTable GetTable(string tablename)
        {
            return Subgroups.FirstOrDefault(x => x.TableSpec.Tablename == tablename);
        }

        public void Add(string fieldName, object value, SqlDbType type)
        {
            Add(new SQLCellInfo() { Fieldname = fieldName, Value = value, DBtype = type }, DefaultTableSpec);
        }

        public void Add(SQLCellInfo newItem, SQLUpdateInfoTableSpecification tableSpec)
        {
            AddToAppropriateSubgroup(newItem, tableSpec);
            ManageReferencesToMainTablePrimaryKey(newItem, tableSpec);
            SQLUpdateInfos.Add(newItem);
            DisplaceEarlierInconsistentChanges();
        }

        private void DisplaceEarlierInconsistentChanges()
        {
            List<Tuple<string, object>> fieldnameAndValueSetToMatch = new List<Tuple<string, object>>();
            int numItemsAdded = SQLUpdateInfos.Count();
            SQLCellInfo lastItem = SQLUpdateInfos[numItemsAdded - 1];
            // If it's an autogeneraetd ID, we're referring to the item by the field values themselves. If there were an earlier addition of the same data that we are adding/deleting now, we must find the matching fieldnames.
            // If it's not an autogenerated ID, then we're making a change to a particular field. Any previous change to that field in this row should be undone, regardless of value match.
            bool searchForValueAsWellAsField = lastItem.RowInfo.TableSpec.IDIsAutogenerated;
            // But there's another possibility: a non-autogenerated ID where we're deleting the row. This is more complicated, and is not impemented yet.
            if (lastItem.Delete && !searchForValueAsWellAsField)
            {
                throw new NotImplementedException(); // We need to delete all items added earlier on this table, and if this is the main table, on all secondary tables. Right now, we're not deleting items in our SQL tables with non-autogen IDs, so this is not implemented.
            }
            if (lastItem.GroupingKey != null && SQLUpdateInfos[numItemsAdded - 1].groupedWithNPreviousItems == 0)
                return; // too early to check
            int numItemsToMatch = lastItem.groupedWithNPreviousItems + 1;
            int numItemsMatched = 0;
            for (int i = numItemsAdded - 1; i >= 0; i--) // look for a matched set going backwards. E.g., if 6 items added and 3 to match, we start at last index (5) and go to (0)
            {
                // start by figuring out what we need to match in earlier items
                if (i + numItemsToMatch >= numItemsAdded) // Continuing e.g., i + 3 >= 6 is true for 3, 4, and 5 
                    fieldnameAndValueSetToMatch.Add(new Tuple<string,object>(SQLUpdateInfos[i].Fieldname, SQLUpdateInfos[i].Value));
                else
                {
                    bool match;
                    if (searchForValueAsWellAsField)
                        match = new Tuple<string, object>(SQLUpdateInfos[i].Fieldname, SQLUpdateInfos[i].Value).Equals(fieldnameAndValueSetToMatch[numItemsMatched]);
                    else
                        match = SQLUpdateInfos[i].Fieldname == fieldnameAndValueSetToMatch[numItemsMatched].Item1;
                    if (match)
                    {
                        numItemsMatched++;
                        if (numItemsMatched == numItemsToMatch)
                        {
                            for (int j = i + numItemsToMatch - 1; j >= i; j--) // E.g., if i == 0 and 3 to match, we go from 2 down to 0.
                            {
                                SQLCellInfo itemToRemove = SQLUpdateInfos[j];
                                SQLUpdateInfos.RemoveAt(j);
                                GetTable(itemToRemove.RowInfo.TableSpec.Tablename).SQLUpdateInfos.Remove(itemToRemove);
                            }
                            numItemsMatched = 0; // reset counter so we can look for more matches
                        }
                    }
                    else
                        numItemsMatched = 0;
                }
            }

        }

        private void AddToAppropriateSubgroup(SQLCellInfo newItem, SQLUpdateInfoTableSpecification tableSpec)
        {
            SQLInfoForCellsInRow_SingleTable subgroup = Subgroups.FirstOrDefault(x => x.TableSpec.Tablename == tableSpec.Tablename);
            if (subgroup == null)
            {
                subgroup = new SQLInfoForCellsInRow_SingleTable(tableSpec);
                // NOTE: If we add support for primary key fields with name other than ID, we'll have to figure that out here.
                Subgroups.Add(subgroup);
            }
            subgroup.Add(newItem);
        }

        private void ManageReferencesToMainTablePrimaryKey(SQLCellInfo newItem, SQLUpdateInfoTableSpecification tableSpec)
        {
            if (tableSpec.IsMainTable && !tableSpec.IDIsAutogenerated && newItem.Fieldname == tableSpec.PrimaryKeyFieldName && newItem.Rownum != null)
            {
                if (MainTablePrimaryKey != null && MainTablePrimaryKey != newItem.Rownum)
                    throw new Exception("Error: Inconsistent primary keys.");
                MainTablePrimaryKey = newItem.Rownum;
                foreach (SQLCellInfo cellInfo in itemsToUpdateWithMainTablePrimaryKeyOnceAvailable)
                {
                    if (cellInfo.RowInfo.TableSpec.HasSameIDAsMainTable && cellInfo.Rownum == null)
                        cellInfo.Rownum = MainTablePrimaryKey;
                    if (cellInfo.SetValueToPrimaryKeyIDOfMainTableOnceLoaded)
                        cellInfo.Value = MainTablePrimaryKey;
                }
            }
            if (newItem.SetValueToPrimaryKeyIDOfMainTableOnceLoaded)
            {
                if (MainTablePrimaryKey == null)
                    itemsToUpdateWithMainTablePrimaryKeyOnceAvailable.Add(newItem);
                else
                    newItem.Value = MainTablePrimaryKey;
            }
            else if (newItem.Rownum == null && newItem.RowInfo.TableSpec.HasSameIDAsMainTable)
            {
                if (MainTablePrimaryKey == null)
                    itemsToUpdateWithMainTablePrimaryKeyOnceAvailable.Add(newItem);
                else
                    newItem.Rownum = MainTablePrimaryKey;
            }
        }
    }

    [Serializable]
    public class SQLInfoForCellsInRow_SingleTable
    {
        public List<SQLCellInfo> SQLUpdateInfos = new List<SQLCellInfo>();
        public SQLUpdateInfoTableSpecification TableSpec;
        public bool MayNeedToCreateDestinationTableRow;
        public int? PrimaryKey;

        public SQLInfoForCellsInRow_SingleTable(SQLUpdateInfoTableSpecification tableSpec)
        {
            TableSpec = tableSpec;

            if (TableSpec.IDIsAutogenerated)
                MayNeedToCreateDestinationTableRow = true; // assume that we will need to create this, but override this assumption as soon as we add an item with an ID
            else if (TableSpec.IDIsAutogenerated)
                MayNeedToCreateDestinationTableRow = true; // always do this 
            else // We have a non-autogenerated ID (i.e., the program generates the ID for this based on something else, such as an ID in another database table)
                MayNeedToCreateDestinationTableRow = false; // assume that we don't need to create a destination table row, but as soon as we get a SQLCellInfo where DataIsAlreadyInDatabase == false, then we set this to true.
        }

        public void Add(SQLCellInfo newItem)
        {
            newItem.RowInfo = this;
            if (TableSpec.IDIsAutogenerated && newItem.Rownum != null)
                MayNeedToCreateDestinationTableRow = false; // since it's autogenerated, we couldn't know the row number if it hadn't been added
            else if (!TableSpec.IDIsAutogenerated && !newItem.DataIsAlreadyInDatabase)
                MayNeedToCreateDestinationTableRow = true; // given any data not clearly marked as already in database, we will assume that data may already exist
            if (newItem.Rownum != null)
                PrimaryKey = newItem.Rownum;

            SQLUpdateInfos.Add(newItem);
        }

        
        public IQueryable<SQLCellInfo> GetUpsertInfos()
        {
            return SQLUpdateInfos.Where(x => x.Upsert).AsQueryable();
        }

        public IQueryable<SQLCellInfo> GetUpdateInfos()
        {
            return SQLUpdateInfos.Where(x => x.Update).AsQueryable();
        }

        public IQueryable<SQLCellInfo> GetDeletionInfos()
        {
            return SQLUpdateInfos.Where(x => x.Delete).AsQueryable();
        }

        public List<string> GetFieldNamesForUpsert()
        {
            return GetUpsertInfos().Select(x => x.Fieldname).ToList();
        }

        public SQLCellInfo GetSQLCellInfoForFieldNameForUpsert(string fieldName, string groupingKey)
        {
            return SQLUpdateInfos.LastOrDefault(x => x.Fieldname == fieldName && x.GroupingKey == groupingKey && x.Upsert); // if there is more than one, we take the last
        }

        public List<string> GetParameterizedValuesLists(List<string> fieldNames, Dictionary<string, string> defaultValues)
        {
            List<string> parameterizedValuesLists = new List<string>();
            List<string> groupingKeys = SQLUpdateInfos.Where(x => x.Upsert).Select(x => x.GroupingKey).Distinct().ToList();
            foreach (string groupingKey in groupingKeys)
            {
                StringBuilder sb = new StringBuilder();
                sb.Append("(");
                bool isFirst = true;
                foreach (string fieldName in fieldNames)
                {
                    string defaultValue = null;
                    SQLCellInfo updateInfo = GetSQLCellInfoForFieldNameForUpsert(fieldName, groupingKey);
                    if (!isFirst)
                        sb.Append(",");
                    if (updateInfo == null)
                    {
                        if (defaultValue == null)
                            defaultValue = defaultValues[fieldName];
                        sb.Append(defaultValue);
                    }
                    else
                        sb.Append(updateInfo.GetValueOrParameterName());
                    if (isFirst)
                        isFirst = false;
                }
                sb.Append(")");
                parameterizedValuesLists.Add(sb.ToString());
            }
            return parameterizedValuesLists;
        }

        public void GetUpdateCommand(out string updateCommand, out List<SQLCellInfo> updateInfos)
        {
            string tableName = TableSpec.Tablename;

            var updateCommands = GetUpdateInfos();

            // step 1: formulate the SQL statement
            if (!updateCommands.Any())
            {
                updateCommand = null;
                updateInfos = null;
                return;
            }

            List<string> updateStringComponents = new List<string>();

            updateStringComponents.AddRange(new string[] { "UPDATE ", tableName, " ", "SET " });
            bool isFirst = true;
            string idvalue = "";
            foreach (var variable in updateCommands)
            {
                if (!(variable.Fieldname == TableSpec.PrimaryKeyFieldName))
                {
                    if (!isFirst)
                        updateStringComponents.Add(", ");
                    isFirst = false;
                    updateStringComponents.Add(variable.Fieldname);
                    if (variable.ValueIsRelative)
                        updateStringComponents.Add(" += ");
                    else
                        updateStringComponents.Add(" = ");
                    updateStringComponents.Add(variable.GetValueOrParameterName());
                }
                else
                    idvalue = variable.Value.ToString();
            }
            updateStringComponents.AddRange(new string[] { " WHERE ", TableSpec.PrimaryKeyFieldName, " = ", idvalue, "; " });
            StringBuilder sb = new StringBuilder();
            foreach (string component in updateStringComponents)
                sb.Append(component);
            updateCommand = sb.ToString();

            foreach (var p in updateCommands)
                if (p.Value == null)
                    p.Value = DBNull.Value;

            updateInfos = updateCommands.OrderBy(x => x.Fieldname == TableSpec.PrimaryKeyFieldName).ToList(); // put ID field last
        }
    }

    [Serializable]
    public class SQLCellInfo
    {
        public SQLInfoForCellsInRow_SingleTable RowInfo = null; // will be set by the row

        public string Fieldname = null;
        public int? Rownum = null;
        public string GroupingKey = null; // If a single row in the main table corresponds to multiple rows in secondary table, we separate out the rows in the secondary table by giving them separate grouping keys.
        public object Value = null;
        public SqlDbType DBtype = SqlDbType.Variant; // must override this
        public string DefaultToUseIfMissing = "NULL";
        public bool Delete = false;
        public bool Upsert { get { return !Delete && RowInfo.MayNeedToCreateDestinationTableRow; } }
        public bool Update { get { return !Delete && !RowInfo.MayNeedToCreateDestinationTableRow; } }
        public bool AlreadyProcessed = false; // initialize to this
        public bool SetValueToPrimaryKeyIDOfMainTableOnceLoaded = false; // set this to true so that value will be TblRowID once that loads
        public bool DataIsAlreadyInDatabase = false;
        public bool ValueIsRelative = false; // use += to update after initial insertion if this is true
        public int groupedWithNPreviousItems = 0; // If there are two items being grouped, set this to 1 for the last one. If there are three, set this to 2 for the last one.

        public string Paramname() 
        {
            string tablename = null;
            if (RowInfo != null)
                tablename = RowInfo.TableSpec.Tablename;

            if (Rownum == null) 
                return Fieldname; 
            if (tablename == null) 
                return Fieldname + Rownum.ToString(); 
            return Fieldname + "R" + Rownum.ToString() + "T" + tablename; 
        }

        public override string ToString()
        {
            return Paramname() + " " + Value.ToString();
        }

        private bool? _parameterRequired = null;
        public bool ParameterRequired()
        {
            if (_parameterRequired == null)
                _parameterRequired = ParameterRequiredHelper();
            return (bool)_parameterRequired;
        }

        private readonly string[] problematicSequences = { ";", "'", "--", "/*", "*/", "xp_" };
        private bool ParameterRequiredHelper()
        {
            bool usingParameter = false;
            if (Value == null)
                return false;


            switch (DBtype)
            {
                case SqlDbType.Bit:
                case SqlDbType.Decimal:
                case SqlDbType.Int:
                case SqlDbType.BigInt:
                case SqlDbType.SmallInt:
                case SqlDbType.Udt:
                case SqlDbType.DateTime:
                    usingParameter = false;
                    break;

                case SqlDbType.NVarChar:
                case SqlDbType.VarChar:
                    string theString = Value as string;
                    usingParameter = problematicSequences.Any(x => theString.Contains(x));
                    break;

            }
            return usingParameter;
        }

        public string GetValueOrParameterName()
        {
            if (Value == null)
            {
                return "NULL";
            }

            if (ParameterRequired())
                return "@" + Paramname();

            switch (DBtype)
            {
                case SqlDbType.Bit:
                    if ((bool)Value)
                        return "1";
                    else
                        return "0";

                case SqlDbType.Decimal:
                case SqlDbType.Int:
                case SqlDbType.BigInt:
                case SqlDbType.SmallInt:
                    return Value.ToString();
                    ;

                case SqlDbType.NVarChar:
                case SqlDbType.VarChar:
                case SqlDbType.NChar:
                case SqlDbType.Char:
                    return "'" + ((string)Value).ToString() + "'";
                    ;

                case SqlDbType.DateTime:
                    return "'" + ((DateTime)Value).Date.ToString("yyyy-MM-dd HH:mm:ss") + "'";

                case SqlDbType.Udt:
                    SQLGeographyInfo geoInfo = (SQLGeographyInfo)Value;
                    string[] geographyComponents = new string[] { "geography::STPointFromText('POINT(' + CAST(", geoInfo.Longitude.ToString(), " AS VARCHAR(20)) + ' ' + CAST(", geoInfo.Latitude.ToString(), " AS VARCHAR(20)) + ')', 4326)" };
                    StringBuilder sb = new StringBuilder();
                    foreach (string gc in geographyComponents)
                        sb.Append(gc);
                    return sb.ToString();
                    ;
            }
            throw new NotImplementedException();
        }
    }

    

    // For geography objects, place a SQLGeographyInfo in value of SQLParameterInfo
    [Serializable]
    public class SQLGeographyInfo
    {
        public decimal Longitude { get; set; }
        public decimal Latitude { get; set; }
    }

    public enum SQLCommandType
    {
        upsert,
        update,
        delete
    }

    public class SQLDatabaseChangeInfo
    {
        public List<SQLInfoForCellsInRow_MainAndSecondaryTables> Rows = new List<SQLInfoForCellsInRow_MainAndSecondaryTables>();

        public void ExecuteAllCommands(ISQLDirectConnectionManager dta)
        {
            GenerateTablenames();
            foreach (string table in Tablenames)
            {
                ExecuteCommands(table, SQLConstants.SQLMaxParameters, dta, SQLCommandType.upsert);
                ExecuteCommands(table, SQLConstants.SQLMaxParameters, dta, SQLCommandType.update);
                ExecuteCommands(table, SQLConstants.SQLMaxParameters, dta, SQLCommandType.delete); 
            }
        }

        private List<string> Tablenames;
        private void GenerateTablenames()
        {
            Tablenames = new List<string>();
            Rows.ForEach(x => x.AddToListOfTablenames(Tablenames));
        }

        public void ExecuteCommands(string tablename, int maxParameters, ISQLDirectConnectionManager dta, SQLCommandType commandType)
        {
            StringBuilder sb;
            List<SQLCellInfo> updateInfos;
            bool moreToDo = true;
            while (moreToDo)
            {
                if (commandType == SQLCommandType.update)
                    GetUpdateCommands(tablename, maxParameters, out sb, out updateInfos, out moreToDo);
                else if (commandType == SQLCommandType.upsert)
                    GetUpsertCommands(tablename, maxParameters, out sb, out updateInfos, out moreToDo);
                else
                {
                    updateInfos = new List<SQLCellInfo>(); // empty list -- we're not using parameters for delete commands (currently)
                    sb = new StringBuilder();
                    GetDeleteCommands(tablename, sb);
                    moreToDo = false;
                }
                if (sb.Length > 0)
                {
                    string command = sb.ToString();
                    SQLDirectManipulate.ExecuteSQLNonQuery(dta, command, updateInfos);
                }
            }
        }

        public void GetUpdateCommands(string tablename, int maxParameters, out StringBuilder sb, out List<SQLCellInfo> updateInfos, out bool moreToDo)
        {
            sb = new StringBuilder();
            updateInfos = new List<SQLCellInfo>();
            int parametersUsed = 0;
            moreToDo = false;
            foreach (var row in Rows.Where(x => !x.IsAlreadyProcessed))
            {
                string updateCommand;
                List<SQLCellInfo> partialUpdateInfos;
                row.GetTable(tablename).GetUpdateCommand(out updateCommand, out partialUpdateInfos);
                if (partialUpdateInfos != null)
                {
                    parametersUsed += partialUpdateInfos.Where(x => x.ParameterRequired()).Count();
                    if (parametersUsed > maxParameters)
                    {
                        moreToDo = true;
                        break;
                    }
                    if (updateCommand != null)
                        sb.Append(updateCommand);
                    updateInfos.AddRange(partialUpdateInfos);
                }
            }
        }

        public void GetUpsertCommands(string tablename, int maxParameters, out StringBuilder sb, out List<SQLCellInfo> updateInfos, out bool moreToDo)
        {
            // The format we're looking for is like the below. So, we'll create a string and then fill in the changeable parts.
            // Note that we'll be using parameters instead of actual values in the Values clause where necessary
            //Merge VTemp AS tbl
            //USING
            //(
            //    Select * FROM
            //    (
            //        Values
            //        (1,5,6),
            //        (2,6,7),
            //        (3,7,9),
            //        (4,8,9),
            //        (5,10,11)
            //    ) as upsert1 (ID, Data1, Data2)
            //) AS upsert2
            //ON tbl.ID = upsert2.ID
            //WHEN NOT MATCHED THEN
            //    INSERT(ID, Data1, Data2)
            //     VALUES(upsert2.ID, upsert2.Data1, upsert2.Data2)
            //WHEN MATCHED THEN
            //    UPDATE SET tbl.ID = upsert2.ID, tbl.Data1 = upsert2.Data1, tbl.Data2 = upsert2.Data2
            //;
            string upsertTemplate = @"
Merge {0} AS tbl 
USING 
( 
	Select * FROM 
	( 
		Values 
		{1} 
	) as upsert1 ({2}) 
) AS upsert2 
ON ({3}) 
WHEN NOT MATCHED THEN 
	INSERT({2}) 
	 VALUES({4}) 
WHEN MATCHED THEN 
	UPDATE SET {5} 
; 
";

            sb = new StringBuilder();
            updateInfos = new List<SQLCellInfo>();
            moreToDo = false;
            var rowsStillToBeUpserted = Rows.Where(x => !x.IsAlreadyProcessed);
            if (!rowsStillToBeUpserted.Any())
                return;
            List<string> fieldNames = GetAffectedFieldNamesForUpsert(tablename);
            if (!fieldNames.Any())
                return;

            Dictionary<string, string> defaultValuesForFieldNames = GetDefaultValuesForUpsert(tablename, fieldNames);
            int maxRows = (maxParameters / fieldNames.Count());
            List<SQLInfoForCellsInRow_MainAndSecondaryTables> rowsToProcess;
            if (maxRows < rowsStillToBeUpserted.Count())
            {
                moreToDo = true;
                rowsToProcess = rowsStillToBeUpserted.Take(maxRows).ToList();
            }
            else
                rowsToProcess = rowsStillToBeUpserted.ToList();

            SQLUpdateInfoTableSpecification tableSpec = null;
            foreach (var row in rowsToProcess)
            {
                SQLInfoForCellsInRow_SingleTable table = row.GetTable(tablename);
                if (tableSpec == null)
                    tableSpec = table.TableSpec;
                foreach (string fieldName in fieldNames)
                {
                    var groupingKeys = table.SQLUpdateInfos.Select(x => x.GroupingKey).Distinct().ToList();
                    foreach (string groupingKey in groupingKeys)
                    {
                        SQLCellInfo updateInfo = table.GetSQLCellInfoForFieldNameForUpsert(fieldName, groupingKey);
                        if (updateInfo != null && !updateInfo.Delete)
                        {
                            updateInfos.Add(updateInfo);
                            updateInfo.AlreadyProcessed = true;
                        }
                    }
                }
            }
           
            string parameterizedValuesList = String.Join(",", rowsToProcess.SelectMany(x => x.GetTable(tablename).GetParameterizedValuesLists(fieldNames, defaultValuesForFieldNames)).ToArray()); // {1}
            string fieldNamesList = String.Join(",", fieldNames.ToArray()); // {2}
            string matchingStatement; // {3}
            if (fieldNames.Contains(tableSpec.PrimaryKeyFieldName))
                matchingStatement = "tbl." + tableSpec.PrimaryKeyFieldName + " = upsert2." + tableSpec.PrimaryKeyFieldName;
            else
                matchingStatement = String.Join(" AND ", fieldNames.Select(x => "tbl." + x + " = upsert2." + x).ToArray());
            string valuesStatement = String.Join(",", fieldNames.Select(x => "upsert2." + x).ToArray()); // {4}
            List<Tuple<string, string>> fieldnameAndAssignmentOperator = new List<Tuple<string, string>>();
            foreach (string fieldname in fieldNames)
                fieldnameAndAssignmentOperator.Add(updateInfos.First(x => x.Fieldname == fieldname).ValueIsRelative ? new Tuple<string,string>(fieldname, " += ") : new Tuple<string,string>(fieldname, " = "));
            string updateStatement = String.Join(",", fieldnameAndAssignmentOperator.Select(x => "tbl." + x.Item1 + x.Item2 + "upsert2." + x.Item1).ToArray()); // {5}
            sb.Append(String.Format(upsertTemplate, tablename, parameterizedValuesList, fieldNamesList, matchingStatement, valuesStatement, updateStatement));
        }

        public List<string> GetAffectedFieldNamesForUpsert(string tablename)
        {
            HashSet<string> included = new HashSet<string>(); // use so we don't have to look at the list each time to see if it's already there
            foreach (var row in Rows)
            {
                List<string> fieldNamesForRow = row.GetTable(tablename).GetFieldNamesForUpsert();
                foreach (string fieldName in fieldNamesForRow)
                {
                    if (!included.Contains(fieldName))
                        included.Add(fieldName);
                }
            }
            return included.ToList();
        }

        public Dictionary<string, string> GetDefaultValuesForUpsert(string tablename, List<string> fieldnames)
        {
            Dictionary<string, string> defaultValues = new Dictionary<string, string>();
            foreach (string fieldname in fieldnames)
                foreach (var row in Rows)
                {
                    SQLCellInfo withFieldname = row.GetTable(tablename).SQLUpdateInfos.FirstOrDefault(x => x.Fieldname == fieldname);
                    if (withFieldname != null)
                    {
                        defaultValues.Add(fieldname, withFieldname.DefaultToUseIfMissing);
                        break;
                    }
                }
            return defaultValues;
        }

        internal void GetDeleteCommands(string tablename, StringBuilder sb)
        {
            // A complication is that each "Row" may refer to several rows in our destination table that we wish to delete. This is because a main table may have secondary tables, with a one-to-many relationship to the main table. For each Row, each GroupingKey corresponds to the SQLCellInfos that collectively define a row in our table to delete.
            var setsOfFieldnameMatches = Rows.SelectMany(x => x.GetTable(tablename).GetDeletionInfos().GroupBy(y => y.GroupingKey).ToList()).Where(x => x.Any()).ToList();
            if (!setsOfFieldnameMatches.Any())
                return;
            // each element of setsOfFieldnameMatches represents a set of fieldnames that must match for the deletion to go through with respect to a particular row. Currently, we support matching 1 or 2 fieldnames.
            // Now, we need to group these by the fieldnames represented
            var augmented = from x in setsOfFieldnameMatches
                                                 let fieldnames = x.Select(y => y.Fieldname).OrderBy(y => y).ToArray()
                                                 let fieldstring = String.Join(",", fieldnames)
                                                 select new { Set = x, Fieldnames = fieldnames, Fieldstring = fieldstring };
            var groupsOfSetsOfFieldnameMatches = from a in augmented
                                                 group a by a.Fieldstring into g
                                                 select new { RowsIdentifiedByFieldnames = g.Select(x => x.Set), Fieldnames = g.First().Fieldnames};
            var groupsList = groupsOfSetsOfFieldnameMatches.ToList();
            foreach (var group in groupsOfSetsOfFieldnameMatches)
            {
                string[] fieldnamesToMatch = group.Fieldnames;
                string deleteCommand;
                if (fieldnamesToMatch.Count() == 1)
                    deleteCommand = SQLDirectManipulate.GetDeleteCommand(tablename, fieldnamesToMatch[0], group.RowsIdentifiedByFieldnames.Select(x => x.Where(y => y.Fieldname == fieldnamesToMatch[0]).First().GetValueOrParameterName()).ToList());
                else if (fieldnamesToMatch.Count() == 2)
                    deleteCommand = SQLDirectManipulate.GetDeleteCommand_TwoFieldsMustMatch(tablename, fieldnamesToMatch[0], group.RowsIdentifiedByFieldnames.Select(x => x.Where(y => y.Fieldname == fieldnamesToMatch[0]).First().GetValueOrParameterName()).ToList(), fieldnamesToMatch[1], group.RowsIdentifiedByFieldnames.Select(x => x.Where(y => y.Fieldname == fieldnamesToMatch[1]).First().GetValueOrParameterName()).ToList(), null);
                else throw new NotImplementedException();
                sb.Append(deleteCommand);
            }
        }
    }

    public static class SQLDirectManipulate
    {
        internal static void ExecuteSQLNonQuery(ISQLDirectConnectionManager database, string command, List<SQLCellInfo> parameters = null)
        {
            if (command == null || command == "")
                return;
            using (SqlConnection connection =
               new SqlConnection(database.GetConnectionString()))
            {
                connection.Open();
                // Create the Command and Parameter objects.
                using (SqlTransaction t = connection.BeginTransaction(IsolationLevel.ReadUncommitted))
                {
                    SqlCommand sqlCommand = new SqlCommand(command, connection, t);
                    if (parameters != null)
                        AddSQLParametersToSqlCommand(parameters, sqlCommand);
                    sqlCommand.ExecuteNonQuery();
                    t.Commit();
                }
            }
        }

        private static void AddSQLParametersToSqlCommand(List<SQLCellInfo> parameters, SqlCommand sqlCommand)
        {
            foreach (SQLCellInfo p in parameters)
            {
                if (p.ParameterRequired())
                {
                    string fullname = "@" + p.Paramname();
                    sqlCommand.Parameters.Add(fullname, p.DBtype);
                    sqlCommand.Parameters[fullname].Value = p.Value ?? DBNull.Value;
                    if (p.DBtype == SqlDbType.Udt)
                        sqlCommand.Parameters[fullname].UdtTypeName = "Geography";
                }
            }
        }

        internal static object ExecuteSQLScalar(ISQLDirectConnectionManager database, string command, List<SQLCellInfo> parameters = null)
        {
            using (SqlConnection connection =
               new SqlConnection(database.GetConnectionString()))
            {
                connection.Open();
                using (SqlTransaction t = connection.BeginTransaction(IsolationLevel.ReadUncommitted))
                {
                    // Create the Command and Parameter objects.
                    SqlCommand sqlCommand = new SqlCommand(command, connection, t);
                    if (parameters != null)
                    {
                        foreach (SQLCellInfo p in parameters)
                        {
                            string fullname = "@" + p.Fieldname;
                            sqlCommand.Parameters.Add(fullname, p.DBtype);
                            sqlCommand.Parameters[fullname].Value = p.Value;
                        }
                    }
                    object result = sqlCommand.ExecuteScalar();
                    t.Commit();
                    return result;
                }
            }
        }

        public static void DropTable(ISQLDirectConnectionManager database, string tableName)
        {
            string dropCommand = String.Format("IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[{0}]') AND type in (N'U')) \n DROP TABLE [dbo].[{0}] \n ", tableName);
            ExecuteSQLNonQuery(database, dropCommand);
        }

        public static void AddTable(ISQLDirectConnectionManager database, SQLTableDescription table)
        {
            DropTable(database, table.Name);
            string colNames = "";
            foreach (var col in table.Columns)
                colNames += col.ToSpecificationString() + ", \n ";
      
            string primaryKey = table.Columns.Single(x => x.PrimaryKey).Name;
            string closingStatement = "(" + primaryKey + "))";
            //string clustered = primaryKey;
            //var otherClustered = table.Columns.SingleOrDefault(x => x.ClusteredIndex && !x.PrimaryKey);
            //if (otherClustered != null)
            //{
            //    clustered = otherClustered.Name;
            //    closingStatement = "CLUSTERED \n ( \n [" + clustered + "] ASC \n )WITH (STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF \n ) \n ) ";
            //}
            //string addCommand = String.Format("CREATE TABLE [dbo].[{0}] ( \n {1} CONSTRAINT [PK_{0}] PRIMARY KEY {2}", table.Name, colNames, closingStatement);
            string addCommand = String.Format("CREATE TABLE [dbo].[{0}] ( \n {1} )", table.Name, colNames);
            ExecuteSQLNonQuery(database, addCommand);
        }

        public static void DeleteMatchingItems(ISQLDirectConnectionManager database, string tableName, string fieldName, List<string> matchingValuesForItemsToDeleteQuotedIfNecessary, string condition=null)
        {
            string deleteCommand = GetDeleteCommand(tableName, fieldName, matchingValuesForItemsToDeleteQuotedIfNecessary, condition);
            ExecuteSQLNonQuery(database, deleteCommand);
        }

        public static string GetDeleteCommand(string tableName, string fieldName, List<string> matchingValuesForItemsToDeleteQuotedIfNecessary, string condition = null)
        {
            if (!matchingValuesForItemsToDeleteQuotedIfNecessary.Any())
                return "";
            var individualMatches = matchingValuesForItemsToDeleteQuotedIfNecessary.Select(x => fieldName + "=" + x);
            string deleteStatement = String.Join(" OR ", individualMatches);
            if (condition == null)
                condition = "";
            else
                condition = " AND (" + condition + ")";
            string deleteCommand = String.Format("DELETE FROM [dbo].[{0}] WHERE ({1}){2};", tableName, deleteStatement, condition);
            return deleteCommand;
        }

        public static void DeleteDoublyMatchingItems(ISQLDirectConnectionManager database, string tableName, string fieldName1, List<string> matchingValuesFieldName1, string fieldName2, List<string> matchingValuesFieldName2, string condition)
        {
            string deleteCommand = GetDeleteCommand_TwoFieldsMustMatch(tableName, fieldName1, matchingValuesFieldName1, fieldName2, matchingValuesFieldName2, condition);
            ExecuteSQLNonQuery(database, deleteCommand);
        }

        public static string GetDeleteCommand_TwoFieldsMustMatch(string tableName, string fieldName1, List<string> matchingValuesFieldName1, string fieldName2, List<string> matchingValuesFieldName2, string condition)
        {
            var individualMatches = matchingValuesFieldName1.Zip(matchingValuesFieldName2, (f1, f2) => "((" + fieldName1 + " = " + f1 + ") AND (" + fieldName2 + " = " + f2 + "))");
            string deleteStatement = String.Join(" OR ", individualMatches);
            if (condition == null)
                condition = "";
            else
                condition = " AND (" + condition + ")";
            string deleteCommand = String.Format("DELETE FROM [dbo].[{0}] WHERE ({1}){2};", tableName, deleteStatement, condition);
            return deleteCommand;
        }



        public static void AddIndicesForSpecifiedColumns(ISQLDirectConnectionManager database, SQLTableDescription table)
        {
            var indexedColumns = table.Columns.Where(x => x.NonclusteredIndex || x.ClusteredIndex).OrderBy(x => !x.ClusteredIndex).ToList();
            foreach (var col in indexedColumns)
            {
                string cmd = "";
                if (col.ColType == SQLColumnType.typeGeography)
                {
                    cmd = String.Format(@"
CREATE SPATIAL INDEX [SIndx_{0}_{1}] ON [dbo].[{0}] 
(
	[{1}]
)USING  GEOGRAPHY_GRID 
WITH (
GRIDS =(LEVEL_1 = MEDIUM,LEVEL_2 = MEDIUM,LEVEL_3 = MEDIUM,LEVEL_4 = MEDIUM), 
CELLS_PER_OBJECT = 16, PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
", table.Name, col.Name);
                }
                else
                {
                    if (col.ClusteredIndex)
                    {
                        if (col.PrimaryKey)
                            continue; // already created
                        cmd = "CREATE CLUSTERED INDEX IX_" + table.Name + "_" + col.Name + " ON " + table.Name + " (" + col.Name + (col.Ascending ? " ASC)" : " DESC) ");
                    }
                    else
                        cmd = "CREATE NONCLUSTERED INDEX IX_" + table.Name + "_" + col.Name + " ON " + table.Name + " (" + col.Name + (col.Ascending ? " ASC)" : " DESC) "); // if the index already existed, we would need to add " WITH (DROP_EXISTING = ON) ", but we get an error if we do that when the index doesn't already exist
                }
                ExecuteSQLNonQuery(database, cmd);
            }
        }

    }
}
