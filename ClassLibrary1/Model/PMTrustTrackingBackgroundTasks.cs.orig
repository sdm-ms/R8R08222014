using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ClassLibrary1.Misc;
using System.Data.Linq;
using System.Diagnostics;

namespace ClassLibrary1.Model
{
    public static class PMTrustTrackingBackgroundTasks
    {
        #region Classes
        internal class TrustTrackerAndUserRatings
        {
#pragma warning disable 0649
            public TrustTracker TrustTracker;
            public TrustTrackerStat[] TrustTrackerStats;
            public UserRating[] UserRatings;
            public IEnumerable<TrustTrackerForChoiceInField>[] TrustTrackerForChoiceInFields;
            public IEnumerable<ChoiceInField>[] ChoiceInFields;
            public Rating[] Ratings;
            public RatingCharacteristic[] RatingCharacteristics;
            public TblRow[] TblRows;
            public Tbl[] Tbls;
#pragma warning restore 0649
        }

        internal class TrustTrackerAndUserInteraction
        {
#pragma warning disable 0649
            public TrustTracker TrustTracker;
            public UserInteraction UserInteraction;
#pragma warning restore 0649
        }

        internal class TrustTrackerUnitAndTrustTrackers
        {
#pragma warning disable 0649
                    return FindAndCorrectUnupdatedLatestUserEgalitarianTrust;
            public IEnumerable<TrustTracker> TrustTrackers;
#pragma warning restore 0649
        }
        #endregion

        /// <summary>
        /// Defines the background tasks. Background tasks return true if they did not finish 
        /// the task based upon the batch size each uses, and false if they did.
        /// 
        /// Defining in this list makes it faster and less error-prone to define new background tasks
        /// </summary>
        static List<Func<IRaterooDataContext, bool>> _BackgroundTasks = new List<Func<IRaterooDataContext,bool>> 
        {
            Update_UserInteraction_WeightInCalculatingTotal_Where_EgalitarianTrustLevel_IsNotCurrent,
            UpdateTrustLevelsBasedOnUserInteractions,
            UpdateUserRatingsThatAreStillMostRecentWhereTrustHasChanged,
            UpdateSkepticalTrustThreshhold,
            UpdateSkepticalTrust,
            DeleteZereodUserInteractions,
        };

        static int _CurrentTaskNumber = 0;

        public static bool DoTrustTrackingBackgroundTasks(IRaterooDataContext RaterooDB)
        {
            int tasksToDo = _BackgroundTasks.Count; // this might be the same background task six times, or each background task separately. this function will return false (no more work to do) only if each background task returns this. (That is why the number is equal to the total number of background tasks, even though some may not be executed.)
            bool moreWorkToDoOnSomeTask = false;
            for (int i = 1; i <= tasksToDo; i++)
            {
                Func<IRaterooDataContext, bool> theTask = GetTask();
                bool moreWorkToDoOnThisTask = theTask(RaterooDB);
                RaterooDB.SubmitChanges();
                if (moreWorkToDoOnThisTask)
                    moreWorkToDoOnSomeTask = true;
                else
                    MoveToNextTask(); // move on to next task only when we've finished previous one
            }
            return moreWorkToDoOnSomeTask;
        }

        internal static void MoveToNextTask()
        {
            _CurrentTaskNumber += 1;
            _CurrentTaskNumber %= _BackgroundTasks.Count; // Wrap _CurrentTaskNumber based upon the defined background tasks
        }

        internal static void CorrectLatestUserEgalitarianTrust(TrustTrackerAndUserInteraction[] items)
        {
            // Trace.TraceInformation("Currently executing trust tracking task: " + currentTask); 
            return _BackgroundTasks[_CurrentTaskNumber];
        }

        internal static bool FindAndCorrectUnupdatedLatestUserEgalitarianTrust(IRaterooDataContext RaterooDB)
        internal static bool Update_UserInteraction_WeightInCalculatingTotal_Where_EgalitarianTrustLevel_IsNotCurrent(IRaterooDataContext RaterooDB)
        {
            const int batchSize = 1000;

            var query =
                from ui in RaterooDB.GetTable<UserInteraction>()
                let tt = ui.GetTrustTracker()
                where ui.LatestUserEgalitarianTrust != tt.EgalitarianTrustLevel // If the UserInteraction's EgalitarianTrustLevel is not up to date with TrustTracker, it needs updating.
                select new 
                { 
                    NewLatestUserEgalitarianTrust = tt.EgalitarianTrustLevel, 
                    UserInteraction = ui 
                };

            var batch = query.Take(batchSize).ToArray();

            CorrectLatestUserEgalitarianTrust(data);
            {
                UserInteraction userInteraction = item.UserInteraction;
                float newLatestUserEgalitarianTrust = item.NewLatestUserEgalitarianTrust;

                if (userInteraction.WeightInCalculatingTrustTotal == 0)
                {
                    if (userInteraction.NumTransactions == 0)
                    {
                        userInteraction.WeightInCalculatingTrustTotal = 0;
                    }
                    else
                    {
                        userInteraction.WeightInCalculatingTrustTotal =
                            (userInteraction.GetNoExtraWeightingStat().SumWeights /
                                (float)userInteraction.NumTransactions) *
                            (float)Math.Log((double)(userInteraction.NumTransactions + 1), 10.0) *
                            newLatestUserEgalitarianTrust;
                    }
                }
                else
                {
                    // denominator can't be 0 because otherwise weightincalculatingtrusttotal would be 0
                    userInteraction.WeightInCalculatingTrustTotal *=
                        newLatestUserEgalitarianTrust /
                        userInteraction.LatestUserEgalitarianTrust; // We shouldn't need to constrain something from the DB; only correctly constrained values should be stored...
                }
                userInteraction.LatestUserEgalitarianTrust = newLatestUserEgalitarianTrust;
            }

            return batch.Count() >= batchSize;
        }
        #endregion

        #region Task: UpdateTrustLevelsBasedOnUserInteractions
        internal static bool UpdateTrustLevelsBasedOnUserInteractions(IRaterooDataContext dataContext)
        {
            const int numToDoAtOnceEachQuery = 50;

            #region DEBUG Starting UpdateTrustLevelsBasedOnUserInteractions
            //Debug.WriteLine("STARTSTARTSTARTSTARTSTART UpdateTrustLevelsBasedOnUserInteractions STARTSTARTSTARTSTARTSTARTSTART");
            #endregion
            #region DEBUG
            //{
            //    Debug.WriteLine("***************************");
            //    var uiStats = from uis in dataContext.GetTable<UserInteractionStat>()
            //                  where uis.UserInteraction.User.TrustTrackers
            //                    .Single(tt => tt.TrustTrackerUnit == uis.UserInteraction.TrustTrackerUnit)
            //                        .NextUpdate < TestableDateTime.Now
            //                  select uis;
            //    foreach (var uiStat in uiStats)
            //        Debug.WriteLine(String.Format("SumWeights: {0}", uiStat.SumWeights));

            //    var usInts = from uis in dataContext.GetTable<UserInteractionStat>()
            //        where uis.UserInteraction.User.TrustTrackers
            //                    .Single(tt => tt.TrustTrackerUnit == uis.UserInteraction.TrustTrackerUnit)
            //                        .NextUpdate < TestableDateTime.Now
            //        select uis.UserInteraction;
            //    usInts = usInts.Distinct();
            //    foreach (var usInt in usInts)
            //        Debug.WriteLine(String.Format("WeightInCalculatingTrustTotal: {0}", usInt.WeightInCalculatingTrustTotal));
            //    Debug.WriteLine("***************************");
            //}
            #endregion

            /* 
             * The reason that all of this is baked into a big complex query: At 
             * the point this code is called, the UserInteractionStats are not yet loaded, so we have to load them from the database. I 
             * suppose that leaves the question of whether we could move part of the code away from Linq to Sql. But some of these things 
             * seem much more efficient at the database level. Critically, we don't want to send much data from the database server back 
             * to the database client. This code gets a lot to happen on the server, including grouping the user interactions, doing some 
             * summations, etc. If we had to look at all the underlying data, that could amount to tens of thousands of pieces of data for 
             * a particular user who had entered ratings (eventually). I think it important for us to keep that kind of calculation in the 
             * database.  That's also why numToDoAtOnceEachQuery is included here, so we don't put too much strain on the database at any 
             * one time for something that needs to be updated once in a while. (Indeed, it's a number we'll need to monitor once we get up 
             * and running to see if we need to lower it.)
             */
            var query = from uis in dataContext.GetTable<UserInteractionStat>()
                        where uis.UserInteraction.User.TrustTrackers
                            .Single(tt => tt.TrustTrackerUnit == uis.UserInteraction.TrustTrackerUnit)
                                .NextUpdate < TestableDateTime.Now /* i.e., the next update time has passed */
                        //let user = uis.UserInteraction.User
                        //let trustTrackerUnit = uis.UserInteraction.TrustTrackerUnit
                        //let statNum = uis.StatNum
                        group uis by new 
                        {
                            User = uis.UserInteraction.User,
                            TrustTrackerUnit = uis.UserInteraction.TrustTrackerUnit,
                            StatNum = uis.StatNum
                        }
                        into groupedUis

                        let trustTracker = groupedUis.Key.User.TrustTrackers
                            .SingleOrDefault(tt => tt.TrustTrackerUnit == groupedUis.Key.TrustTrackerUnit)
                        let trustTrackerStat = trustTracker.TrustTrackerStats
                            .SingleOrDefault(tts => tts.StatNum == groupedUis.Key.StatNum)

                        // calculate weighted average of the user interaction stats for a particular user and statnum (e.g., large delta ratings)
                        let trustNumeratorItems = groupedUis.Select(guis =>
                            guis.SumWeights == 0 ?
                                0 :
                                guis.UserInteraction.WeightInCalculatingTrustTotal * guis.SumAdjustPctTimesWeight / guis.SumWeights)
                        let trustDenominatorItems = groupedUis.Select(guis =>
                            guis.SumWeights == 0 ?
                                0 :
                                guis.UserInteraction.WeightInCalculatingTrustTotal)
                        let trustNumerator = trustNumeratorItems.Sum()
                        let trustDenominator = trustDenominatorItems.Sum()
                        let trustValue = trustDenominator == 0 ? 1F : trustNumerator / trustDenominator

                        let trustTotalWeights = groupedUis.Sum(guis => guis.SumWeights)

                        let egalitarianTrustItems = groupedUis.Select(guis =>
                            guis.SumWeights == 0 ?
                                0 :
                                guis.SumAdjustPctTimesWeight / guis.SumWeights)
                        let egalitarianTrustValue = egalitarianTrustItems.Average().ConstrainEgalitarianTrust()

                        select new 
                        {
                            TrustTrackerStat = trustTrackerStat,
                            TrustTracker = trustTracker,
                            TrustValue = trustValue,
                            TrustTotalWeights = trustTotalWeights,
                            EgalitarianTrustValue = egalitarianTrustValue,
                            DEBUG_UserId = trustTracker.UserID,
                        };

            var trustTrackersAndStatsRequiringUpdating = query.Take(numToDoAtOnceEachQuery).ToArray();

            // Before we actually do the updating of the trust trackers and stats
            // Update TrustTrackerUnit update parameters
            // If we start to get backed up, we want to make it so that we don't update trust trackers
            // as often. Once we are no longer backed up, then we'll go back to usual.
            // These changes won't apply until next query, since we don't submit changes between making
            //  the changes and performing the query.
            var trustTrackersUnitsNeedingUpdate = dataContext.GetTable<TrustTracker>()
                .Where(tt => tt.NextUpdate < TestableDateTime.Now)
                .Select(tt => tt.TrustTrackerUnit).Distinct();
            if (trustTrackersAndStatsRequiringUpdating.Length == numToDoAtOnceEachQuery) /* i.e., if it is the maximum number */
            {
                foreach (var ttu in trustTrackersUnitsNeedingUpdate)
                {
                    // The following two give us the bounds in the update interval for all users.
                    ttu.MinUpdateIntervalSeconds = (int)(ttu.MinUpdateIntervalSeconds * TrustTrackerUnit.IntervalUpdateFactor);
                    ttu.MaxUpdateIntervalSeconds = (int)(ttu.MaxUpdateIntervalSeconds * TrustTrackerUnit.IntervalUpdateFactor);
                    // When the delta in the trust level is below a threshold after we have updated the trust level for a particular user, we extend the interval for the particular user so that we will not be looking at the user for a while longer. So, let's raise that threshold (which applies to all users) since we're backed up.
                    ttu.ExtendIntervalWhenChangeIsLessThanThis = ttu.ExtendIntervalWhenChangeIsLessThanThis * (decimal)TrustTrackerUnit.IntervalUpdateFactor;
                }
            }
            else
            {
                // Return to Defaults
                foreach (var ttu in trustTrackersUnitsNeedingUpdate)
                {
                    ttu.MinUpdateIntervalSeconds = TrustTrackerUnit.DefaultMinUpdateIntervalSeconds;
                    ttu.MaxUpdateIntervalSeconds = TrustTrackerUnit.DefaultMaxUpdateIntervalSeconds;
                    ttu.ExtendIntervalWhenChangeIsLessThanThis = TrustTrackerUnit.DefaultExtendIntervalWhenChangeIsLessThanThis;
                }
            }

            // Now, let's actually update the trust trackers and stats, using the values that we
            // already had the database compute.
            foreach (var datum in trustTrackersAndStatsRequiringUpdating)
            {
                #region debug
                //Debug.WriteLine(String.Format("Datum: UserID: {0}; Numer: {1}; Denom: {2}", 
                //    datum.TrustTracker.UserID, datum.Debug_TrustNum, datum.Debug_TrustDenom));
                //if (datum.TrustTracker.UserID == 2)
                //    Debug.WriteLine("");
                #endregion
                datum.TrustTrackerStat.TrustValue = datum.TrustValue;
                datum.TrustTrackerStat.SumWeights = datum.TrustTotalWeights;
                if (datum.TrustTrackerStat.StatNum == 1)
                {
                    datum.TrustTracker.OverallTrustLevel = datum.TrustValue;
                    datum.TrustTracker.EgalitarianTrustLevel = datum.EgalitarianTrustValue;
                    #region debug
                    //{// Debug
                    //    Debug.WriteLine(String.Format("<User {0}> Overall/SkepticalTrust {1}/{2}", datum.TrustTracker.UserID, 
                    //        datum.TrustTracker.OverallTrustLevel, datum.TrustTracker.SkepticalTrustLevel));
                    //}
                    #endregion
                    // This is the change in trust since the last time that we updated the user's unchallenged user ratings
                    datum.TrustTracker.DeltaOverallTrustLevel = Math.Abs(datum.TrustTracker.OverallTrustLevel - datum.TrustTracker.LastOverallTrustLevel);
                    #region debug
                    //if (datum.TrustTracker.DeltaOverallTrustLevel > 0)
                    //    Debug.WriteLine(String.Format("{0} User {1} Trust (±{2})", TestableDateTime.Now, datum.TrustTracker.UserID, datum.TrustTracker.DeltaOverallTrustLevel));
                    #endregion
                    if (datum.TrustTracker.DeltaOverallTrustLevel < (float)datum.TrustTracker.TrustTrackerUnit.ExtendIntervalWhenChangeIsLessThanThis)
                    {
                        // When the user's overall trust level has changed only a bit (since the last time that Rateroo updated the user's unchallenged user ratings), then that indicates that we don't need to pay as much attention to updating this user's trust level, so we extend the interval.
                        datum.TrustTracker.UpdateIntervalSeconds =
                            Math.Min(
                                (int)(datum.TrustTracker.UpdateIntervalSeconds *
                                    datum.TrustTracker.TrustTrackerUnit.ExtendIntervalMultiplier),
                                datum.TrustTracker.TrustTrackerUnit.MaxUpdateIntervalSeconds);
                    }
                    else
                    {
                        // We better look at this user again soon, since it appears that this user's trust is in flux.
                        datum.TrustTracker.UpdateIntervalSeconds = datum.TrustTracker.TrustTrackerUnit.MinUpdateIntervalSeconds;
                    }
                }
                datum.TrustTracker.NextUpdate = TestableDateTime.Now.AddSeconds(datum.TrustTracker.UpdateIntervalSeconds);
            }
            #region debug
            //Debug.WriteLine("ENDENDENDENDENDENDENDENDENDENDENDENDENDENDENDENDEND");
            #endregion

            return trustTrackersAndStatsRequiringUpdating.Length == numToDoAtOnceEachQuery;
        }
        #endregion

        #region Task: UpdateUserRatingsThatAreStillMostRecentWhereTrustHasChanged
        internal static bool UpdateUserRatingsThatAreStillMostRecentWhereTrustHasChanged(IRaterooDataContext RaterooDB)
        {
            if (TrustTrackerTrustEveryone.ShouldTrustEveryoneForTestingPurposes)
                return false; // no more work to do

            const int numToDoAtOnceEachQuery = 10;
            var query = from tt in RaterooDB.GetTable<TrustTracker>()
                        where tt.DeltaOverallTrustLevel > 0.05F || tt.MustUpdateIsTrustedOnNotSubsequentlyRated
                        orderby tt.DeltaOverallTrustLevel descending
                        let userRatings = tt.User.UserRatings.Where(ur =>
                                !ur.SubsequentlyRated &&
                                !ur.ShortTermResolutionReflected &&
                                ur.RatingPhaseStatus.ShortTermResolutionValue == null &&
                                !ur.LongTermResolutionReflected &&
                                tt.TrustTrackerUnitID == ur.TrustTrackerUnitID)
                        let trustTrackerForChoiceInFields = userRatings.Select(ur =>
                            ur.TrustTrackerForChoiceInFieldsUserRatingLinks.Select(t => t.TrustTrackerForChoiceInField))
                        let choiceInFields = trustTrackerForChoiceInFields.Select(ttfcif => ttfcif.Select(t => t.ChoiceInField))
                        let ratings = userRatings.Select(ur => ur.Rating)
                        let ratingCharacteristics = ratings.Select(r => r.RatingGroup.RatingGroupAttribute.RatingCharacteristic)
                        let tblRows = ratings.Select(r => r.RatingGroup.TblRow)
                        let tbls = tblRows.Select(tr => tr.Tbl)
                        select new TrustTrackerAndUserRatings 
                            {
                                TrustTracker = tt,
                                TrustTrackerStats = tt.TrustTrackerStats.ToArray(),
                                UserRatings = userRatings.ToArray(),
                                TrustTrackerForChoiceInFields = trustTrackerForChoiceInFields.ToArray(),
                                ChoiceInFields = choiceInFields.ToArray(),
                                Ratings = ratings.ToArray(),
                                RatingCharacteristics = ratingCharacteristics.ToArray(),
                                TblRows = tblRows.ToArray(),
                                Tbls = tbls.ToArray()
                            };

            var data = query.Take(numToDoAtOnceEachQuery).ToArray();
            #region debug

            //if (data.Where(d => d.TrustTracker.UserID == 2 && d.TrustTracker.DeltaOverallTrustLevel > 0).Count() > 0)
            //{
            //    var userRatings = data.Single(d => d.TrustTracker.UserID == 2).TrustTracker.User.UserRatings.ToArray();
            //    String.Format("Breakpoint here.");
            //}
            //foreach (var datum in data)
            //{
            //    Debug.WriteLine(String.Format("User {0} DeltaOverallTrust: {1}", datum.TrustTracker.UserID, datum.TrustTracker.DeltaOverallTrustLevel));
            //}
            #endregion

            UpdateUserRatingsThatAreStillMostRecentBasedOnTrustTrackers(RaterooDB, data);
            #region debug
            // DEBUG
            //var tt = data.FirstOrDefault(x => x.TrustTracker.UserID == 3);
            //if (tt != null)
            //    Trace.TraceInformation("TrustTracker for user being updated new trust level " + tt.TrustTracker.OverallTrustLevel);
            //else
            //{
            //    var tt2 = RaterooDB.GetTable<TrustTracker>().FirstOrDefault(x => x.UserID == 3);
            //    if (tt2 != null)
            //        Trace.TraceInformation("TrustTracker for user not being updated. Overall trust and delta trust: " + tt2.OverallTrustLevel + " " + tt2.DeltaOverallTrustLevel);
            //}
            #endregion

            return data.Count() == numToDoAtOnceEachQuery;
        }
        internal static void UpdateUserRatingsThatAreStillMostRecentBasedOnTrustTrackers(
            IRaterooDataContext dataContext, 
            TrustTrackerAndUserRatings[] trustTrackersAndUserRatings)
        {
            foreach (var trustTrackerAndUserRatings in trustTrackersAndUserRatings)
            {
                trustTrackerAndUserRatings.TrustTracker.MustUpdateIsTrustedOnNotSubsequentlyRated = false; // will do below
                int userRatingsCount = trustTrackerAndUserRatings.UserRatings.Count();
                for (int i = 0; i < userRatingsCount; i++)
                {
                    UserRating userRating = trustTrackerAndUserRatings.UserRatings[i];
                    Rating rating = trustTrackerAndUserRatings.Ratings[i];
                    TblRow tblRow = trustTrackerAndUserRatings.TblRows[i];
                    Tbl tbl = trustTrackerAndUserRatings.Tbls[i];
                    RatingCharacteristic ratingCharacteristic = trustTrackerAndUserRatings.RatingCharacteristics[i];

                    TrustTrackerStatManager manager = new TrustTrackerStatManager(userRating, ratingCharacteristic,
                        trustTrackerAndUserRatings.TrustTrackerStats);
                    userRating.NewUserRating = manager.CalculateRatingPrediction(userRating);

                    bool rowRequiresUpdate = false;
                    if (userRating.NewUserRating != null && rating.CurrentValue != userRating.NewUserRating)
                    {
                        rating.CurrentValue = userRating.NewUserRating;
                        rowRequiresUpdate = true;
                        rating.LastModifiedResolutionTimeOrCurrentValue = TestableDateTime.Now; // trigger recalculation of points for all previous user ratings for the same rating
                    }
                    bool previousIsTrusted = userRating.IsTrusted;
                    userRating.IsTrusted =
                        // if there is a previous rating, then if we trust you even a little bit, we won't give you an asterisk, because we will already be adjusting your user rating based on the degree to which we trust you
                        (userRating.PreviousDisplayedRating != null && trustTrackerAndUserRatings.TrustTracker.SkepticalTrustLevel > TrustTracker.OldUserRatingSkepticalTrustCutoff) ||
                        // but if this is the very first rating, then we don't know what the baseline is, so we need to indicate that this is untrusted unless you are very trustworthy
                        (userRating.PreviousDisplayedRating == null && trustTrackerAndUserRatings.TrustTracker.SkepticalTrustLevel > TrustTracker.NewUserRatingSkepticalTrustCutoff);
                    if (userRating.NewUserRating != null && previousIsTrusted != userRating.IsTrusted)
                    {
                        if (userRating.IsTrusted)
                        {
                            rating.LastTrustedValue = userRating.NewUserRating;
                        }
                        else
                        {
                            if (userRating.PreviousDisplayedRating == null)
                                rating.LastTrustedValue = null;
                            else
                                rating.LastTrustedValue = userRating.PreviousRatingOrVirtualRating;
                        }
                        rowRequiresUpdate = true;
                        rating.LastModifiedResolutionTimeOrCurrentValue = TestableDateTime.Now; // trigger recalculation of points for all previous user ratings
                    }
                    if (rowRequiresUpdate)
                        SQLFastAccess.IdentifyRowRequiringUpdate(dataContext, tbl, tblRow.TblRowID, true, false);
                }
                trustTrackerAndUserRatings.TrustTracker.LastOverallTrustLevel = trustTrackerAndUserRatings.TrustTracker.OverallTrustLevel;
                trustTrackerAndUserRatings.TrustTracker.DeltaOverallTrustLevel = 0;
            }
        }
        #endregion

        #region Task: UpdateSkepticalTrustThreshhold
        static bool skepticalTrustThreshholdUpdateComplete = true;
        static int numCompletedSkepticalTrustThreshhold = 0;
        static DateTime? lastUpdateOfSkepticalTrustThreshhold;
        internal static bool UpdateSkepticalTrustThreshhold(IRaterooDataContext RaterooDB)
        {
            if (skepticalTrustThreshholdUpdateComplete && (lastUpdateOfSkepticalTrustThreshhold == null || ((DateTime)lastUpdateOfSkepticalTrustThreshhold) + TimeSpan.FromMinutes(32) < TestableDateTime.Now))
            {
                skepticalTrustThreshholdUpdateComplete = false;
                numCompletedSkepticalTrustThreshhold = 0;
            }

            const int numToDoAtOnceEachQuery = 100;

            bool moreToDoSkepticalTrustThreshholdUpdate = !skepticalTrustThreshholdUpdateComplete;
            if (moreToDoSkepticalTrustThreshholdUpdate)
            {
                var query =
                        from x in RaterooDB.GetTable<TrustTrackerUnit>()
                        select new TrustTrackerUnitAndTrustTrackers { TrustTrackerUnit = x, TrustTrackers = x.TrustTrackers }
                 ;
                var data = query.Skip(numCompletedSkepticalTrustThreshhold).Take(numToDoAtOnceEachQuery).ToArray();
                foreach (var datum in data)
                {
                    short skepticalTrustThreshhold = GetSkepticalTrustThreshhold(datum.TrustTrackers);
                    datum.TrustTrackerUnit.SkepticalTrustThreshhold = skepticalTrustThreshhold;
                }
                skepticalTrustThreshholdUpdateComplete = data.Count() != numToDoAtOnceEachQuery;
                if (skepticalTrustThreshholdUpdateComplete)
                {
                    moreToDoSkepticalTrustThreshholdUpdate = false;
                    lastUpdateOfSkepticalTrustThreshhold = TestableDateTime.Now;
                }
                else
                    numCompletedSkepticalTrustThreshhold += numToDoAtOnceEachQuery;
            }

            return moreToDoSkepticalTrustThreshholdUpdate;
        }
        /// <summary>
        /// Skeptical trust: A user's overall trust level depends on all the user's UserInteractionStats. 
        /// However, where a user is relatively new, we might not want to give full weight to that overall 
        /// trust level; that is, we want to put an asterisk next to the user's user ratings when the data 
        /// producing the overall trust level is relatively unreliable. The user in that case can still
        /// receive points, but the asterisk provides an indication and an incentive for other users to 
        /// validate whether that user rating is accurate. The question is how much data we need before we 
        /// trust a user enough to set the skeptical trust equal to the overall trust level, instead of equal 
        /// to zero. When there are very few users, we need to trust more, and so we have a very low 
        /// skeptical trust threshold, but as the user base grows, we demand more user ratings that have 
        /// been rerated by distinct users, and so the skeptical trust threshold increases, but never to 
        /// more than 25.
        /// </summary>
        /// <param name="TrustTrackers"></param>
        /// <returns></returns>
        internal static short GetSkepticalTrustThreshhold(IEnumerable<TrustTracker> TrustTrackers)
        {
            int skepticallyTrusted = TrustTrackers.Count(x => x.SkepticalTrustLevel > 0);
            int numToReturn = (int)Math.Sqrt(skepticallyTrusted) - 3;
            if (numToReturn < 0)
                numToReturn = 0;
            else if (numToReturn > 25)
                numToReturn = 25;
            return (short)numToReturn;
        }
        #endregion

        #region Task: UpdateSkepticalTrust
        static bool updateSkepticalTrustComplete = true;
        static int numCompletedSkepticalTrust = 0;
        static DateTime? lastUpdateOfSkepticalTrust;
        internal static bool UpdateSkepticalTrust(IRaterooDataContext RaterooDB)
        {
            if (updateSkepticalTrustComplete)
            {
                updateSkepticalTrustComplete =
                    (lastUpdateOfSkepticalTrust == null ||
                    lastUpdateOfSkepticalTrust.Value + TimeSpan.FromMinutes(10) < TestableDateTime.Now);
                numCompletedSkepticalTrust = 0;
            }

            const int numToDoAtOnceEachQuery = 1000;
            bool moreToDo = !updateSkepticalTrustComplete;

            if (moreToDo)
            {
                var query = from tt in RaterooDB.GetTable<TrustTracker>()
                            where (
                                // skeptical trust not yet at trust level -- we'll see if that's changed
                                (tt.SkepticalTrustLevel != tt.OverallTrustLevel) ||
                                // the threshhold has changed, so we had better check things even where SkepticalTrustLevel == TrustLevel, because we could demote SkepticalTrust back to zero.
                                (tt.TrustTrackerUnit.LastSkepticalTrustThreshhold != tt.TrustTrackerUnit.SkepticalTrustThreshhold)
                                )
                            let numUserInteractionsWithTrustedLatestUsers =
                                tt.User.UserInteractions.Count(y => y.TrustTrackerUnit == tt.TrustTrackerUnit && y.LatestUserEgalitarianTrust > 0)
                            select new { TrustTrackerUnit = tt.TrustTrackerUnit, TrustTracker = tt, NumUserInteractionsWithTrustedLatestUsers = numUserInteractionsWithTrustedLatestUsers };
                var data = query.Skip(numCompletedSkepticalTrust).Take(numToDoAtOnceEachQuery).ToArray();
                foreach (var datum in data)
                {
                    float previousSkepticalTrustLevel = datum.TrustTracker.SkepticalTrustLevel;
                    if (datum.NumUserInteractionsWithTrustedLatestUsers >= datum.TrustTrackerUnit.SkepticalTrustThreshhold)
                        datum.TrustTracker.SkepticalTrustLevel = datum.TrustTracker.OverallTrustLevel; // could be negative
                    else
                        datum.TrustTracker.SkepticalTrustLevel = 0;
                    datum.TrustTrackerUnit.LastSkepticalTrustThreshhold = datum.TrustTrackerUnit.SkepticalTrustThreshhold;
                    if ((previousSkepticalTrustLevel > TrustTracker.NewUserRatingSkepticalTrustCutoff != 
                            datum.TrustTracker.SkepticalTrustLevel > TrustTracker.NewUserRatingSkepticalTrustCutoff) 
                        ||
                        (previousSkepticalTrustLevel > TrustTracker.OldUserRatingSkepticalTrustCutoff != 
                            datum.TrustTracker.SkepticalTrustLevel > TrustTracker.OldUserRatingSkepticalTrustCutoff))
                        // we've changed the side of the threshold we're on, so we must update userratings and ratings where there have been no subsequent ratings, i.e. unchallenged user ratings
                        datum.TrustTracker.MustUpdateIsTrustedOnNotSubsequentlyRated = true;
                }

                updateSkepticalTrustComplete = data.Count() != numToDoAtOnceEachQuery;
                if (updateSkepticalTrustComplete)
                {
                    lastUpdateOfSkepticalTrust = TestableDateTime.Now;
                    moreToDo = false;
                }
                else
                    numCompletedSkepticalTrust += numToDoAtOnceEachQuery;
            }
            return moreToDo;
        }
        #endregion

        #region Task: DeleteZereodUserInteractions
        /// <summary>
        /// Although we only use the latest user interaction for the purposes of trust calculation,
        /// UserInteractions in the database still exist even when it is no longer the case that there are any user ratings
        /// where user A entered a user rating and user B has made the latest rating.  This task should remove all
        /// UserInteractions that are no longer be used for trust calcuation.  These UserInteractions should be the 
        /// same as those with NumTransactions == 0, because we rely upon methods elsewhere to adjust NumTransactions
        /// when a UserInteraction's LatestRatingUser becomes no longer the latest rating user.
        /// </summary>
        /// <param name="dataContext"></param>
        /// <returns></returns>
        internal static bool DeleteZereodUserInteractions(IRaterooDataContext dataContext)
        {
            const int numToDoAtOnce = 1000;

            bool moreToDo = false;

            IQueryable<UserInteraction> zeroedUserInteractionsQuery =
                dataContext.GetTable<UserInteraction>().Where(ui => ui.NumTransactions == 0);
            if (zeroedUserInteractionsQuery.Count() > numToDoAtOnce)
                moreToDo = true;

            UserInteraction[] zeroedUserInteractions = zeroedUserInteractionsQuery.Take(numToDoAtOnce).ToArray();

            // If we are using our home-made in-memory database, there is not on-delete-cascade behavior,
            // so we have delete any dependent records ourselves.  It's possible that we could add this
            // behavior to some kind of OnDelete event of the DataContext
            if (!dataContext.IsRealDatabase())
            {
                IEnumerable<UserInteractionStat> userInteractionStats = zeroedUserInteractions.SelectMany(ui => ui.UserInteractionStats);
                dataContext.GetTable<UserInteractionStat>().DeleteAllOnSubmit(userInteractionStats);
            }

            dataContext.GetTable<UserInteraction>().DeleteAllOnSubmit(zeroedUserInteractions);

            return moreToDo;
        }
        #endregion
    }
}
